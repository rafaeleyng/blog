<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="preload" href="https://fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic&amp;display=optional" as="style"/><title>Redis: Pipelining, Transactions and Lua Scripts</title><meta name="description" content="Rafael Eyng&#x27;s tech blog"/><meta name="language" content="en"/><meta name="content-language" content="en"/><meta name="author" content="Rafael Eyng"/><meta name="keywords" content="software, development, javascript, github, node, docker, blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="canonical" href="https://rafaeleyng.github.io/redis-pipelining-transactions-and-lua-scripts"/><link rel="shortcut icon" href="/favicon.png" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic&amp;display=optional" rel="stylesheet" type="text/css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-154633858-1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-154633858-1');
</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/cf64dab97a0355ddac54e129c3acb55aff14938f_CSS.7b3f6175.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf64dab97a0355ddac54e129c3acb55aff14938f_CSS.7b3f6175.chunk.css"/><link rel="preload" href="/_next/static/dEkFoDhXLch93PZLjykdg/pages/post.js" as="script"/><link rel="preload" href="/_next/static/dEkFoDhXLch93PZLjykdg/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.03885e3762b811c06d48.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.2d46a4062a63030a7155.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-fd16d9fd7045bb52879a.js" as="script"/><link rel="preload" href="/_next/static/chunks/a1bc03cf.5784ec4ab76361fe4054.js" as="script"/><link rel="preload" href="/_next/static/chunks/cf64dab97a0355ddac54e129c3acb55aff14938f.1f2abe620427fc640b4f.js" as="script"/><link rel="preload" href="/_next/static/chunks/cf64dab97a0355ddac54e129c3acb55aff14938f_CSS.c4a6afef92e8dd991da1.js" as="script"/></head><body><div id="__next"><div class="container"><header class="site-header single-column"><a class="blog-title" href="/">Rafael Eyng&#x27;s Blog</a><nav class="blog-menu"><a target="_blank" rel="noopener" href="https://rafaeleyng.github.io/me">About</a><a target="_blank" rel="noopener" href="https://github.com/rafaeleyng/rafaeleyng.github.io">Github</a></nav></header></div><header class="page-header"><div class="container single-column"><h1>Redis: Pipelining, Transactions and Lua Scripts</h1><p class="post-meta"><time itemProp="datePublished" dateTime="2019-11-24">Nov 24, 2019</time></p></div></header><main class="container single-column"><section class="post"><span class="hidden" itemProp="publisher">Rafael Eyng</span><span class="hidden" itemProp="keywords">redis, pipelining, transaction, lua, scripts</span><article class="post-content" itemProp="articleBody"><p>Redis offers 3 ways of grouping commands: pipelining, transactions and Lua scripts. The subtleties of using one instead of the other are explored on this post, in terms of the benefits they present, their limitations and atomicity.</p><h2>Pipelining</h2><p>Think of pipelining as purely an optimization for sending multiple commands at a lower computational cost. Is the simplest of the three and offers less guarantees.</p><p>Pipelining in Redis consists of sending multiple commands to the server in the same message, separating commands by newline. You can test this (assuming you have Redis running locally on default port 6379) with <code>printf &quot;INCR x\r\nINCR x\r\n&quot; | nc localhost 6379</code>. This sends a single message containing two commands, separated by newlines. It is sometimes referred as &quot;batching&quot; in some libraries. Note that there is no special commands to mark the start or the end of a pipeline. It is really just a bunch of commands grouped together.</p><p>The server buffers all the answers in memory and sends all at once when the pipeline is done. So the pipeline size must not be too big that the server will have to hold a lot of answers in memory. Using a few thousands of commands inside a pipeline is usually a good starting point.</p><h3>Benefits of pipelining</h3><p>It provides two main benefits in terms of performance:</p><ul><li>batching several commands in a single message allows us to save multiple times the round trip time between the client and the Redis server</li><li>it avoids context switching, both in the client and in the server. When the server or the client need to read from/write to the network, a syscall is made and an expensive context switch happens between user space and kernel space. If we send 10 messages, each with a single command, 10 context switches will happen. If we send a single message with 10 commands, it&#x27;s likely that a single context switch will be needed.</li></ul><h3>Atomicity of pipelining</h3><p>It is worth knowing that the part of Redis that executes client commands is single-threaded. Also, that all commands in Redis are atomic, executed individually. This means that Redis doesn&#x27;t stop any command half-way through its execution to execute another command. Every individual command that is started is finished without interleaving with other commands.</p><p>But <strong>pipelining is not atomic</strong>. Imagine that you have 2 clients talking to the same Redis server, and both send at the same time a pipeline consisting of 5 commands each. While is guaranteed that all commands from Client 1 pipeline will be executed in order, there is no guarantee that they won&#x27;t be interleaved with commands from Client 2 pipeline.</p><p>This image shows one of the multiple possible interleavings between two concurrent pipelines being executed:</p><p><img alt="pipelines interleaving" src="https://user-images.githubusercontent.com/4842605/69572324-ad031380-0fa2-11ea-9db2-12a5c6ac9e41.png"/></p><p>This behavior shows that pipelining is non-blocking on the server. This means that even if a Client 1 has a huge and slow pipeline, other clients won&#x27;t be blocked, because the commands from the other clients will be interleaved with the commands from Client 1 pipeline.</p><h3>Limitations of pipelining</h3><p>The clients only gets the command&#x27;s response after executing all the pipeline. So if a client sends a pipeline with 5 commands, it will receive at the end an array with the response for each command.</p><p>If some command fails, the pipeline continues and an error is returned at the end, as the response for that specific command (not for the whole pipeline). You can test it with <code>printf &quot;SET name rafael\r\nINCR name\r\nGET name\r\n&quot; | nc localhost 6379</code> (note the error on the second line, but the last command gets executed anyway):</p><pre><code>+OK
-ERR value is not an integer or out of range
$6
rafael</code></pre><p>So you cannot, inside a pipeline, read some value from Redis and use the value later in a command inside the same pipeline.</p><h3>When you should use pipelining</h3><p>Use pipeline when (all of the bellow):</p><ul><li>you need performance</li><li>you have several commands to send to the Redis server</li><li>you don&#x27;t need the response of a previous command as input for a subsequent command (because you only get all responses in the end).</li></ul><hr/><h2>Transactions</h2><p>Redis transactions have a different semantics than &quot;transactions&quot; in a RDBMS context.</p><p>Transactions in Redis are a mechanism for queuing commands, and later deciding whether we want to executed all of them (atomically) or give up and don&#x27;t execute any command.</p><p>Unlike pipelines, pipelines use special commands to mark the beginning and the end of the transaction, and the server also can queue the commands from a transaction (so the client can send one at a time). So transactions are stateful on the server, it actually keeps track of an ongoing transaction. Besides that, some libraries prefer to buffer the commands client-side and send the whole transaction inside a pipeline for optimization.</p><p>A transaction works by issuing a <code>MULTI</code> command, then sending all the commands that compose the pipeline, and an <code>EXEC</code> or a <code>DISCARD</code> at the end.</p><h3>Benefits of transactions</h3><p>If pipelining is used on the library, all the performance benefits from using pipeline will apply.</p><p>Transactions also provide a &quot;check-and-set&quot; with the <code>WATCH</code> command. Imagine the scenario:</p><ul><li>before the transaction, we read a value from key <code>my-key</code> and store it in our program</li><li>we start the transaction with <code>MULTI</code></li><li>we queue commands inside the transaction, using the value read from key <code>my-key</code></li><li>we <code>EXEC</code> the transaction</li></ul><p>In this scenario, we can use <code>WATCH</code> to avoid running the transaction with an old value of <code>my-key</code>, in the case that the value changed between we read it and we executed the transaction.</p><h3>Atomicity of transactions</h3><p><strong>Transactions are atomic</strong>. There is no interleaving of commands inside a transaction with commands from outside that transaction. The attention point is that transactions are blocking. If you have a client with a huge and slow transaction being executed, all other clients will have to wait to be served.</p><h3>Limitations of transactions</h3><p>Like pipelining, using transactions we don&#x27;t have the ability to use intermediate values for subsequent commands. We only get the whole list of responses at the end.</p><p>If an error happens in one of the commands, there are 2 possibilities:</p><ul><li>if it is a syntax error (like wrong number of arguments), it is detected while queuing the commands and the transaction won&#x27;t even be executed.</li><li>if it is a semantic error (like an operation on the wrong data type), it is only detected while executing the transaction, and (just like with pipelines), the error will be returned inside the list of responses, as the response for the specific command. But subsequent commands in the queue will be executed normally, and the transaction won&#x27;t be aborted. This means that Redis doesn&#x27;t have a rollback mechanism like traditional RDBMS.</li></ul><h3>When you should use transactions</h3><p>You should use transactions if (all of the bellow):</p><ul><li>you need atomic execution of commands</li><li>you don&#x27;t need intermediate values to compose subsequent commands</li></ul><hr/><h2>Lua Scripts</h2><p>Redis can execute client-provided scripts written in Lua. This is by far the method that opens more possibilities of the 3 presented here.</p><p>A Lua script is loaded on the Redis server and can be later invoked with parameters (using the <code>EVALSHA</code> command). You can also send the whole script on every invocation (with the <code>EVAL</code> command), but you should avoid doing this for performance reasons.</p><h3>Benefits of Lua scripts</h3><p>Unlike with pipelining and transactions, in a Lua script we can manipulate intermediate results. It is, we can read a value from Redis using a command, store the result in a Lua variable, and later use the value in a command or even in some logic like an <code>if</code> statement. We can also execute inside a Lua script any Redis command that the server supports. In the following example we use parameters (both <code>KEYS</code> and <code>ARGV</code>), issue Redis commands, read intermediate values, and use values we&#x27;ve read in the script logic.</p><pre><code class="language-lua">local key = KEYS[1]
local new = ARGV[1]

local current = redis.call(&#x27;GET&#x27;, key)
if (current == false) or (tonumber(new) &lt; tonumber(current)) then
  redis.call(&#x27;SET&#x27;, key, new)
  return 1
else
  return 0
end</code></pre><h3>Atomicity of Lua scripts</h3><p><strong>Lua scripts are atomic</strong>. Likewise transactions, they are blocking and can make other clients wait for a long time if the script is slow.</p><h3>Limitations of Lua scripts</h3><p>While there is no limitations in terms of functionality of Lua scripts, it might be weird to use it to implement a huge pipeline with atomicity. In a pipeline we would add commands to the pipeline, going as far as thousands of commands. How to implement this with scripts? Either generate a script dynamically with the current commands, which would not perform well (because we could not reuse the script with <code>EVALSHA</code>), or make a loop inside the script and call it with a huge number (thousands) of parameters. I&#x27;ve never needed to do this, but just seems weird and I&#x27;m not sure it would work.</p><h3>When you should use Lua scripts</h3><p>You should use Lua scripts if (all of the bellow):</p><ul><li>you need atomic execution of commands</li><li>you need intermediate values to compose subsequent commands</li><li>you need intermediate values to conditionally execute commands</li></ul><hr/><h2>References</h2><ul><li><a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a></li><li><a href="https://redis.io/topics/transactions">https://redis.io/topics/transactions</a></li><li><a href="https://redis.io/commands/eval">https://redis.io/commands/eval</a></li><li><a href="https://www.slideshare.net/RedisLabs/atomicity-in-redis-thomas-hunter">https://www.slideshare.net/RedisLabs/atomicity-in-redis-thomas-hunter</a></li><li><a href="https://stackoverflow.com/questions/29327544/pipelining-vs-transaction-in-redis">https://stackoverflow.com/questions/29327544/pipelining-vs-transaction-in-redis</a></li><li><a href="https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers">https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers</a></li><li><a href="https://stackexchange.github.io/StackExchange.Redis/Transactions">https://stackexchange.github.io/StackExchange.Redis/Transactions</a></li></ul></article><div id="disqus_thread"></div><script type="text/javascript">
var disqus_config = function () {
  this.page.url = 'https://rafaeleyng.github.io/redis-pipelining-transactions-and-lua-scripts';
  this.page.identifier = '/redis-pipelining-transactions-and-lua-scripts';
};

(function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://rafaeleyng.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></section></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"document":{"content":"\nRedis offers 3 ways of grouping commands: pipelining, transactions and Lua scripts. The subtleties of using one instead of the other are explored on this post, in terms of the benefits they present, their limitations and atomicity.\n\n## Pipelining\n\nThink of pipelining as purely an optimization for sending multiple commands at a lower computational cost. Is the simplest of the three and offers less guarantees.\n\nPipelining in Redis consists of sending multiple commands to the server in the same message, separating commands by newline. You can test this (assuming you have Redis running locally on default port 6379) with `printf \"INCR x\\r\\nINCR x\\r\\n\" | nc localhost 6379`. This sends a single message containing two commands, separated by newlines. It is sometimes referred as \"batching\" in some libraries. Note that there is no special commands to mark the start or the end of a pipeline. It is really just a bunch of commands grouped together.\n\nThe server buffers all the answers in memory and sends all at once when the pipeline is done. So the pipeline size must not be too big that the server will have to hold a lot of answers in memory. Using a few thousands of commands inside a pipeline is usually a good starting point.\n\n### Benefits of pipelining\n\nIt provides two main benefits in terms of performance:\n- batching several commands in a single message allows us to save multiple times the round trip time between the client and the Redis server\n- it avoids context switching, both in the client and in the server. When the server or the client need to read from/write to the network, a syscall is made and an expensive context switch happens between user space and kernel space. If we send 10 messages, each with a single command, 10 context switches will happen. If we send a single message with 10 commands, it's likely that a single context switch will be needed.\n\n### Atomicity of pipelining\n\nIt is worth knowing that the part of Redis that executes client commands is single-threaded. Also, that all commands in Redis are atomic, executed individually. This means that Redis doesn't stop any command half-way through its execution to execute another command. Every individual command that is started is finished without interleaving with other commands.\n\nBut **pipelining is not atomic**. Imagine that you have 2 clients talking to the same Redis server, and both send at the same time a pipeline consisting of 5 commands each. While is guaranteed that all commands from Client 1 pipeline will be executed in order, there is no guarantee that they won't be interleaved with commands from Client 2 pipeline.\n\nThis image shows one of the multiple possible interleavings between two concurrent pipelines being executed:\n\n![pipelines interleaving](https://user-images.githubusercontent.com/4842605/69572324-ad031380-0fa2-11ea-9db2-12a5c6ac9e41.png)\n\n\nThis behavior shows that pipelining is non-blocking on the server. This means that even if a Client 1 has a huge and slow pipeline, other clients won't be blocked, because the commands from the other clients will be interleaved with the commands from Client 1 pipeline.\n\n### Limitations of pipelining\n\nThe clients only gets the command's response after executing all the pipeline. So if a client sends a pipeline with 5 commands, it will receive at the end an array with the response for each command.\n\nIf some command fails, the pipeline continues and an error is returned at the end, as the response for that specific command (not for the whole pipeline). You can test it with `printf \"SET name rafael\\r\\nINCR name\\r\\nGET name\\r\\n\" | nc localhost 6379` (note the error on the second line, but the last command gets executed anyway):\n\n```\n+OK\n-ERR value is not an integer or out of range\n$6\nrafael\n```\n\nSo you cannot, inside a pipeline, read some value from Redis and use the value later in a command inside the same pipeline.\n\n### When you should use pipelining\n\nUse pipeline when (all of the bellow):\n- you need performance\n- you have several commands to send to the Redis server\n- you don't need the response of a previous command as input for a subsequent command (because you only get all responses in the end).\n\n---\n\n## Transactions\n\nRedis transactions have a different semantics than \"transactions\" in a RDBMS context.\n\nTransactions in Redis are a mechanism for queuing commands, and later deciding whether we want to executed all of them (atomically) or give up and don't execute any command.\n\nUnlike pipelines, pipelines use special commands to mark the beginning and the end of the transaction, and the server also can queue the commands from a transaction (so the client can send one at a time). So transactions are stateful on the server, it actually keeps track of an ongoing transaction. Besides that, some libraries prefer to buffer the commands client-side and send the whole transaction inside a pipeline for optimization.\n\nA transaction works by issuing a `MULTI` command, then sending all the commands that compose the pipeline, and an `EXEC` or a `DISCARD` at the end.\n\n### Benefits of transactions\n\nIf pipelining is used on the library, all the performance benefits from using pipeline will apply.\n\nTransactions also provide a \"check-and-set\" with the `WATCH` command. Imagine the scenario:\n- before the transaction, we read a value from key `my-key` and store it in our program\n- we start the transaction with `MULTI`\n- we queue commands inside the transaction, using the value read from key `my-key`\n- we `EXEC` the transaction\n\nIn this scenario, we can use `WATCH` to avoid running the transaction with an old value of `my-key`, in the case that the value changed between we read it and we executed the transaction.\n\n### Atomicity of transactions\n\n**Transactions are atomic**. There is no interleaving of commands inside a transaction with commands from outside that transaction. The attention point is that transactions are blocking. If you have a client with a huge and slow transaction being executed, all other clients will have to wait to be served.\n\n### Limitations of transactions\n\nLike pipelining, using transactions we don't have the ability to use intermediate values for subsequent commands. We only get the whole list of responses at the end.\n\nIf an error happens in one of the commands, there are 2 possibilities:\n- if it is a syntax error (like wrong number of arguments), it is detected while queuing the commands and the transaction won't even be executed.\n- if it is a semantic error (like an operation on the wrong data type), it is only detected while executing the transaction, and (just like with pipelines), the error will be returned inside the list of responses, as the response for the specific command. But subsequent commands in the queue will be executed normally, and the transaction won't be aborted. This means that Redis doesn't have a rollback mechanism like traditional RDBMS.\n\n### When you should use transactions\n\nYou should use transactions if (all of the bellow):\n- you need atomic execution of commands\n- you don't need intermediate values to compose subsequent commands\n\n---\n\n## Lua Scripts\n\nRedis can execute client-provided scripts written in Lua. This is by far the method that opens more possibilities of the 3 presented here.\n\nA Lua script is loaded on the Redis server and can be later invoked with parameters (using the `EVALSHA` command). You can also send the whole script on every invocation (with the `EVAL` command), but you should avoid doing this for performance reasons.\n\n### Benefits of Lua scripts\n\nUnlike with pipelining and transactions, in a Lua script we can manipulate intermediate results. It is, we can read a value from Redis using a command, store the result in a Lua variable, and later use the value in a command or even in some logic like an `if` statement. We can also execute inside a Lua script any Redis command that the server supports. In the following example we use parameters (both `KEYS` and `ARGV`), issue Redis commands, read intermediate values, and use values we've read in the script logic.\n\n```lua\nlocal key = KEYS[1]\nlocal new = ARGV[1]\n\nlocal current = redis.call('GET', key)\nif (current == false) or (tonumber(new) \u003c tonumber(current)) then\n  redis.call('SET', key, new)\n  return 1\nelse\n  return 0\nend\n```\n\n### Atomicity of Lua scripts\n\n**Lua scripts are atomic**. Likewise transactions, they are blocking and can make other clients wait for a long time if the script is slow.\n\n### Limitations of Lua scripts\n\nWhile there is no limitations in terms of functionality of Lua scripts, it might be weird to use it to implement a huge pipeline with atomicity. In a pipeline we would add commands to the pipeline, going as far as thousands of commands. How to implement this with scripts? Either generate a script dynamically with the current commands, which would not perform well (because we could not reuse the script with `EVALSHA`), or make a loop inside the script and call it with a huge number (thousands) of parameters. I've never needed to do this, but just seems weird and I'm not sure it would work.\n\n### When you should use Lua scripts\n\nYou should use Lua scripts if (all of the bellow):\n- you need atomic execution of commands\n- you need intermediate values to compose subsequent commands\n- you need intermediate values to conditionally execute commands\n\n---\n\n## References\n\n- https://redis.io/topics/pipelining\n- https://redis.io/topics/transactions\n- https://redis.io/commands/eval\n- https://www.slideshare.net/RedisLabs/atomicity-in-redis-thomas-hunter\n- https://stackoverflow.com/questions/29327544/pipelining-vs-transaction-in-redis\n- https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers\n- https://stackexchange.github.io/StackExchange.Redis/Transactions\n","data":{"title":"Redis: Pipelining, Transactions and Lua Scripts","date":"2019-11-25T00:00:00.000Z","keywords":"redis, pipelining, transaction, lua, scripts","excerpt":"Redis offers 3 ways of grouping commands: pipelining, transactions and Lua scripts. The subtleties of using one instead of the other are explored on this post.\n"}},"slug":"redis-pipelining-transactions-and-lua-scripts"}}},"page":"/post","query":{"slug":"redis-pipelining-transactions-and-lua-scripts"},"buildId":"dEkFoDhXLch93PZLjykdg","nextExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/runtime/polyfills-2998c20c30097f9c8a42.js"></script><script async="" data-next-page="/post" src="/_next/static/dEkFoDhXLch93PZLjykdg/pages/post.js"></script><script async="" data-next-page="/_app" src="/_next/static/dEkFoDhXLch93PZLjykdg/pages/_app.js"></script><script src="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" async=""></script><script src="/_next/static/chunks/framework.03885e3762b811c06d48.js" async=""></script><script src="/_next/static/chunks/commons.2d46a4062a63030a7155.js" async=""></script><script src="/_next/static/runtime/main-fd16d9fd7045bb52879a.js" async=""></script><script src="/_next/static/chunks/a1bc03cf.5784ec4ab76361fe4054.js" async=""></script><script src="/_next/static/chunks/cf64dab97a0355ddac54e129c3acb55aff14938f.1f2abe620427fc640b4f.js" async=""></script><script src="/_next/static/chunks/cf64dab97a0355ddac54e129c3acb55aff14938f_CSS.c4a6afef92e8dd991da1.js" async=""></script><script src="/_next/static/dEkFoDhXLch93PZLjykdg/_buildManifest.js" async=""></script><script src="/_next/static/dEkFoDhXLch93PZLjykdg/_ssgManifest.js" async=""></script></body></html>